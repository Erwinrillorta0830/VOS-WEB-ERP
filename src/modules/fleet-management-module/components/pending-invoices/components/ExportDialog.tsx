"use client";

import * as React from "react";
import { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from "@/components/ui/command";
import { Check, ChevronsUpDown, Download, Loader2 } from "lucide-react";
import { cn } from "@/lib/utils";

import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"; 
import { format, startOfMonth, endOfMonth, subDays, addDays, startOfYear, endOfYear } from "date-fns";
import type { PendingInvoiceOptions } from "../types";

import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import * as XLSX from "xlsx";
import { saveAs } from "file-saver";

function yyyyMMdd(d: Date) { return format(d, "yyyy-MM-dd"); }
function money(n: number) { return Number(n || 0).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }); }

type Preset = "All Time" | "Yesterday" | "Today" | "Tomorrow" | "This Week" | "This Month" | "This Year" | "Custom";

function SearchableSelect({
  value,
  onChange,
  options,
  placeholder,
  label
}: {
  value: string;
  onChange: (val: string) => void;
  options: { value: string; label: string }[];
  placeholder: string;
  label: string;
}) {
  const [open, setOpen] = React.useState(false);

  return (
    <Popover open={open} onOpenChange={setOpen} modal={true}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="w-full justify-between font-normal text-slate-900 bg-white border-slate-200"
        >
          {value === "All"
            ? label
            : options.find((opt) => opt.value === value)?.label || label}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-[300px] p-0" align="start">
        <Command>
          <CommandInput placeholder={placeholder} />
          <CommandList className="max-h-[300px] overflow-y-auto overflow-x-hidden">
            <CommandEmpty>No results found.</CommandEmpty>
            <CommandGroup>
              <CommandItem
                value="All"
                onSelect={() => {
                  onChange("All");
                  setOpen(false);
                }}
              >
                <Check
                  className={cn(
                    "mr-2 h-4 w-4",
                    value === "All" ? "opacity-100" : "opacity-0"
                  )}
                />
                All
              </CommandItem>
              {options.map((option) => (
                <CommandItem
                  key={option.value}
                  value={option.label}
                  onSelect={() => {
                    onChange(option.value);
                    setOpen(false);
                  }}
                >
                  <Check
                    className={cn(
                      "mr-2 h-4 w-4",
                      value === option.value ? "opacity-100" : "opacity-0"
                    )}
                  />
                  {option.label}
                </CommandItem>
              ))}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}

export function ExportDialog({ open, onClose, options }: { open: boolean; onClose: () => void; options: PendingInvoiceOptions | null; }) {
  const [salesmanId, setSalesmanId] = React.useState<string>("All");
  const [customerCode, setCustomerCode] = React.useState<string>("All");
  const [status, setStatus] = React.useState<string>("All");
  
  const [preset, setPreset] = React.useState<Preset>("All Time");
  const [dateFrom, setDateFrom] = React.useState<string>("");
  const [dateTo, setDateTo] = React.useState<string>("");

  const [formatType, setFormatType] = React.useState<"PDF" | "Excel">("PDF");
  const [isExporting, setIsExporting] = React.useState(false);

  const salesmanOptions = React.useMemo(() => {
    return (options?.salesmen ?? []).map((s) => {
        const parts = s.label.split(" - ");
        let displayName = parts.length > 1 ? parts.slice(1).join(" - ").trim() : s.label;
        if (!displayName) displayName = parts[0].trim();
        return { value: String(s.id), label: displayName };
    });
  }, [options?.salesmen]);

  const customerOptions = React.useMemo(() => {
    return (options?.customers ?? []).map(c => ({ value: c.code, label: c.label }));
  }, [options?.customers]);

  React.useEffect(() => {
    const now = new Date();
    if (preset === "All Time") {
      setDateFrom("");
      setDateTo("");
    } else if (preset === "Yesterday") {
      setDateFrom(yyyyMMdd(subDays(now, 1)));
      setDateTo(yyyyMMdd(subDays(now, 1)));
    } else if (preset === "Today") {
      setDateFrom(yyyyMMdd(now));
      setDateTo(yyyyMMdd(now));
    } else if (preset === "Tomorrow") {
      setDateFrom(yyyyMMdd(addDays(now, 1)));
      setDateTo(yyyyMMdd(addDays(now, 1)));
    } else if (preset === "This Month") {
      setDateFrom(yyyyMMdd(startOfMonth(now)));
      setDateTo(yyyyMMdd(endOfMonth(now)));
    } else if (preset === "This Year") {
      setDateFrom(yyyyMMdd(startOfYear(now)));
      setDateTo(yyyyMMdd(endOfYear(now)));
    } else if (preset === "This Week") {
      setDateFrom(yyyyMMdd(subDays(now, 3)));
      setDateTo(yyyyMMdd(addDays(now, 3)));
    }
  }, [preset]);

  async function loadReportRows() {
    const p = new URLSearchParams();
    if (status !== "All") p.set("status", status);
    if (salesmanId !== "All") p.set("salesmanId", salesmanId);
    if (customerCode !== "All") p.set("customerCode", customerCode);
    if (dateFrom) p.set("dateFrom", dateFrom);
    if (dateTo) p.set("dateTo", dateTo);
    
    p.set("page", "1");
    p.set("pageSize", "100000");

    // âœ… FIX: Added { cache: 'no-store' } to ensure fresh data for every export
    const res = await fetch(`/api/pending-invoices?${p.toString()}`, { cache: "no-store" });
    
    if (!res.ok) throw new Error("Failed to fetch report data");
    const json = await res.json();
    
    return Array.isArray(json?.rows) ? json.rows : [];
  }

  async function handleExport() {
    try {
      setIsExporting(true);
      const rows = await loadReportRows();

      if (rows.length === 0) {
        alert("No data found for the selected criteria.");
        setIsExporting(false);
        return;
      }

      if (formatType === "Excel") {
        const header = ["Invoice No", "Date", "Customer", "Salesman", "Net Amount", "Dispatch Plan", "Status"];
        const body = rows.map((r: any) => [
          r.invoice_no, 
          r.invoice_date, 
          r.customer, 
          r.salesman, 
          Number(r.net_amount),
          r.dispatch_plan === 'unlinked' ? '-' : r.dispatch_plan, 
          r.pending_status
        ]);
        
        const ws = XLSX.utils.aoa_to_sheet([header, ...body]);
        
        (ws as any)["!cols"] = [
            { wch: 15 }, // Invoice
            { wch: 12 }, // Date
            { wch: 30 }, // Customer
            { wch: 20 }, // Salesman
            { wch: 15 }, // Amount
            { wch: 20 }, // Plan
            { wch: 15 }, // Status
        ];

        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "PendingInvoices");
        const buf = XLSX.write(wb, { bookType: "xlsx", type: "array" });
        saveAs(new Blob([buf], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" }), `PendingInvoices-${preset}.xlsx`);
      } else {
        const doc = new jsPDF({ orientation: "landscape", unit: "pt", format: "a4" });
        doc.setFontSize(14);
        doc.text("Pending Invoice Report", 40, 40);
        doc.setFontSize(10);
        
        const dateStr = preset === "All Time" ? "All Time" : `${dateFrom} to ${dateTo}`;
        doc.text(`Range: ${dateStr} | Status: ${status}`, 40, 55);

        const body = rows.map((r: any) => [
            r.invoice_no, 
            r.invoice_date,
            String(r.customer ?? "").substring(0, 30),
            String(r.salesman ?? "").substring(0, 20),
            money(r.net_amount),
            r.dispatch_plan === 'unlinked' ? '-' : r.dispatch_plan,
            r.pending_status
        ]);

        autoTable(doc, {
            startY: 70,
            head: [["Invoice No", "Date", "Customer", "Salesman", "Net Amount", "Plan", "Status"]],
            body: body,
            styles: { fontSize: 9 },
            headStyles: { fillColor: [20, 20, 20] }, 
            columnStyles: {
                4: { halign: 'right' }, 
            }
        });
        doc.save(`PendingInvoices-${preset}.pdf`);
      }
      onClose();
    } catch (e) {
      console.error(e);
      alert("Failed to export report");
    } finally {
      setIsExporting(false);
    }
  }

  return (
    <Dialog open={open} onOpenChange={(v) => !v && onClose()}>
      <DialogContent className="max-w-[700px] p-0 overflow-visible gap-0 bg-white">
        <DialogHeader className="p-6 pb-4 border-b">
          <DialogTitle className="text-xl font-bold text-slate-900">What needs to be printed?</DialogTitle>
          <p className="text-sm text-slate-500 mt-1">Filters select the criteria for the printed report.</p>
        </DialogHeader>

        <div className="p-6 grid grid-cols-1 md:grid-cols-2 gap-6">
            
            <div className="space-y-2">
                <label className="text-[11px] font-bold text-slate-400 uppercase tracking-wide">Salesman</label>
                <SearchableSelect 
                    label="All Salesmen"
                    placeholder="Search salesman..."
                    value={salesmanId}
                    onChange={setSalesmanId}
                    options={salesmanOptions}
                />
            </div>

            <div className="space-y-2">
                <label className="text-[11px] font-bold text-slate-400 uppercase tracking-wide">Customer</label>
                <SearchableSelect 
                    label="All Customers"
                    placeholder="Search customer..."
                    value={customerCode}
                    onChange={setCustomerCode}
                    options={customerOptions}
                />
            </div>

            <div className="md:col-span-2 space-y-2">
                <label className="text-[11px] font-bold text-slate-400 uppercase tracking-wide">Status</label>
                <Select value={status} onValueChange={setStatus}>
                    <SelectTrigger className="bg-white border-slate-200"><SelectValue /></SelectTrigger>
                    <SelectContent>
                        {["All", "Unlinked", "For Dispatch", "Inbound", "Cleared"].map(s => (
                            <SelectItem key={s} value={s}>{s === "All" ? "All Statuses (Full Matrix)" : s}</SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>
            <div className="md:col-span-2 space-y-2">
                <label className="text-[11px] font-bold text-slate-400 uppercase tracking-wide">Date Range</label>
                <div className="flex flex-wrap gap-2">
                    {["All Time", "Today", "Tomorrow", "This Week", "This Month", "This Year", "Custom"].map(p => (
                        <Button 
                            key={p} 
                            variant={preset === p ? "default" : "outline"} 
                            onClick={() => setPreset(p as Preset)}
                            className={preset === p ? "bg-slate-900 hover:bg-slate-800 text-white" : "bg-white border-slate-200 text-slate-600"}
                            size="sm"
                        >
                            {p}
                        </Button>
                    ))}
                </div>
                {preset === "Custom" && (
                     <div className="flex gap-4 pt-2">
                        <input type="date" value={dateFrom} onChange={e => setDateFrom(e.target.value)} className="border p-2 rounded text-sm" />
                        <input type="date" value={dateTo} onChange={e => setDateTo(e.target.value)} className="border p-2 rounded text-sm" />
                     </div>
                )}
            </div>
            <div className="md:col-span-2 space-y-2">
                 <label className="text-[11px] font-bold text-slate-400 uppercase tracking-wide">Format</label>
                 <div className="flex gap-4">
                     <label className="flex items-center gap-2 text-sm cursor-pointer"><input type="radio" checked={formatType === "PDF"} onChange={() => setFormatType("PDF")} /> PDF</label>
                     <label className="flex items-center gap-2 text-sm cursor-pointer"><input type="radio" checked={formatType === "Excel"} onChange={() => setFormatType("Excel")} /> Excel</label>
                 </div>
            </div>
        </div>

        <DialogFooter className="bg-slate-50 p-4 border-t gap-3">
          <Button variant="outline" onClick={onClose} className="border-slate-300">Cancel</Button>
          <Button onClick={handleExport} disabled={isExporting} className="bg-slate-900 hover:bg-slate-800 text-white gap-2 min-w-[140px]">
            {isExporting ? <Loader2 className="w-4 h-4 animate-spin" /> : <Download className="w-4 h-4" />} Print Report
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}